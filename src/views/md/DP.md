## 文档说明

​	本文档用于记录DP学习和准备选修上课讲授。

## 动态规划引入

​	动态规划(Dynamic programming，简称DP)。他是一种将复杂问题转化很多子问题，并将子问题进行求解，并将子问题的答案存储起来，避免重复计算相同子问题的一种算法。

​	动态规划一般用于解决最优问题。

## 从生活问题引入

​	对于概念可能大家不是那么好理解，那咱们就用生活中的实例，来引出本文所要讲述的内容。在咱们国家，货币的面额分别100，50，20，10，5，1七种。假设同学你是一个超级大土豪，你身上带了足够的不同种类的货币，你现在的目标是，凑出某个金额，且使用的货币数量最少。

​	假如我想让你凑出15元，你会怎么凑？

​	理论上来说，大部分人都会说10元一张5元一张。很好，这就是这种情况的最优策略，如果要问采取的策略是什么的话，不出以外是:10元能行就先拿一张10元的，剩下五元就拿张五元的不就好了。

​	但是如果我要是让你换一组面额的货币呢，比如面额只有1，5，11三种面额的金额呢？

​	这样，上述的策略便变得不太好用了，因为如果我们要是还要按照上述的策略的话，我们会拿面额11的一张，1元面额的4张，这样总共就在使用了5张，而我们如果只拿5元的话，我们只需要拿三张就好了。

​	那么，我们要思考一下，为什么第一种策略对于第二种方法不太适用呢，因为第一种属于是一种"鼠目寸光"的选择方法，第一种策略让我们尽可能的选择更大面额的货币，这种方式在货币面额合理的情况下固然是对的，但如果货币本身就存在漏洞，我们这种策略就是错误的。第一种策略就是著名的贪心策略，我们只需要选择当前的最优，不用考虑之后是什么情况，是一种不考虑后续的策略。

​	第二种策略便是本文介绍的主角，动态规划。我们在做出第二种选择方式的时候，是因为我们判定出，如果我们要拿一张11的话，我们就要拿出更多数量的1元。相反如果我要是选择5元面额的，我可以使用更少数量的货币。我们也可以换一种更具有逻辑的思维方式，我们要分解一个15元，首先我们拿出一张11元的货币，这时候我们需要面对的问题便变成了如果分解一个4元的货币，然后我们就用一元对4元货币进行分解，最后统计出的答案。我们拿过11元分解，然后再拿5元来分解，重复上述的行为，我们得出先用5元来分解最后总数比上一种情况少，保留答案。

​	这就是动态规划，将一个问题分解为很多子问题，分别求解子问题的解，最后得出大问题的答案。

## 	动态规划的三要素

​	根据上述的例子，我们可以总结出动态规划的三要素。

#### 最优化原理

​	最优化原理，也叫最优子结构。一个最优化的策略必须具有这样的性质，无论过去的状态和决策如何如何，对于前面的决策形成的状态而言，余下的决策必须构成最优策略。简言而之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。后面阶段的状态是因前面状态推导出来的。

#### 无后效性

​	将各个阶段的问题按照一定次序排列好之后，对于某个给定的阶段的状态，他以前各阶段的状态无法直接影星他未来的决策，只能通过当前这个状态。换句话说，每个状态的截至都是对于他之前的所有状态的完整总结。

#### 子问题的重叠性

​	在我们判断当前状态的过程中，会有大部分的重复状态，我们利用空间，将这些子状态的结果都存储下来，避免相同子问题的重复计算，从而提升算法效率。在本质上来说，动态规划是一种利用空间换时间的技术。

## 解决动态规划问题的基本思路

#### 1.确定状态

​	将原问题划分为若干个阶段，每个阶段对应一个子问题，提取子问题的状态；

​	一般是从最后一步从底层一步一步往上逆推。

​	确定状态是解决动态规划问题的起始，我们需要确定我们到底想要观测整个过程中的什么状态，确定每种状态的形成。

#### 2.确定状态转移方程

​	寻找每一个状态的可能决策，各状态间的相互转移方式。

​	确定状态转移方程是动态规划问题的难点，如果根据已知的状态，将后续的内容计算出，需要我们确定一个相应的方程。

#### 3.确定开始以及边界条件

​	确定起始状态和边界状态对于动态规划来说也是很重要的，初态应该是什么我们应该如何判定是否结束，需要我们一开头考虑好。

#### 4.按照顺序求解每个阶段的问题

​	上述的进行求解。

## 线性动态规划

​	线性动态规划是动态规划的一种，它是一种状态具有线性划分的动态规划。

​	线性动态规划中，大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量i表示，i的大小表示了问题的规模的大小，因此从小到大推i直到推到n，就得到了大规模问题的解，这就是线性动态规划的过程。

​	按照数据形式，线性动态规划解决的问题主要是单串，双串，矩阵上的问题，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小。因此从前往后推位置就相当于从小问题到大问题的推演。

​	线性动态规划是动态规划最基础的一类，问题的形式，dp状态方程的设计变化会有很多。

​	对于解决动态规划问题，还是需要结合自己的做题经验去积累。

## 背包问题

背包问题是线性dp种的典型问题。

背包问题分为01背包问题，完全背包问题，多重背包问题，接下来我们一一进行讲解。

#### 01背包问题

​	什么是01背包问题呢？

​	01背包问题指的是那种，给你一定量的不同物品，每个物品只有一件，你有一个确定容量的背包，根据你的选择你可以选择是否装。

​	举个例子，你要去水果摊拿水果，每种水果都有两个属性，一个是水果的价值，一个是水果的大小。老板跟你说每种说过你最多只能拿一个。因此我们会想如何拿水果，不超过背包的容量，而且水果的价值最大。

​	如果我们不能非常简单的判断出怎么拿的话，这时候我们就会一次一次试，当拿不同组合的水果时，每次都记录价值，最后处理完所有，我们使用价值最大的那组水果就可以了。

​	但是这种每种排列都进行尝试的方式会浪费我们大量的宝贵时间，因此，我们可以使用动态规划的思想。该问题是一个典型的01背包问题。

​	首先，对于01背包问题，每种水果只有一个，我们对于每种水果的选择只有买与不买两种，最优的选择肯定在不同的选择之中。

​	我们要是想要知道第n中水果买与不买，这个决定取决于第n-1种水果买或者不买哪种更合适。我们想要的是答案的最优解，那么我们取到n-1的便是最优解了，那么我们在取n的最优解的时候，一定是要比n-1不是最优解的时候得到的结果要更好。所以取最优解这个过程相当于从小数据一直向后推，直到推到目标数据，得出答案。这体现了动态规划的三大要素。

​	所以根据我们得出的结论，我们可以总结出，当我们决定买第i种水果的时候，只需要判断出背包在之前所有状态中的最大价值，与现在的价值相比，取最大值得出现在的值。我们可以总结出该问题的状态转移方程。
$$
dp[j] = max(dp[j], dp[j - o[i].w] + o[i].val)
$$
​	给出的是用滚动数组优化后的方程，个人感觉比二维数组还好理解。

###### 	本例代码实现

~~~c++
struct shuiguo {
    int val;//价值
    int w;//重量
}o[Nn];
int dp[Nn];
int main() {
    fastread();
    int v;//背包容量
    int n; //水果种类
    cin >> v >> n;
    for (int i = 1; i <= n; i++) {
        cin >> o[i].w >> o[i].val;
    }
    for (int i = 1; i <= n; i++) { //表示的选择的第几个水果
        for (int j = v; j >= o[i].w; j--) {  //表示背包的容量
            dp[j] = max(dp[j], dp[j - o[i].w] + o[i].val);
        }
    }
    cout << dp[v];
    return 0;
}
~~~

​	我们已经学习完了01背包的思想和对应的动态回归方程，让我们做几道题感受一下。

##### [P1048 [NOIP2005 普及组] 采药]([P1048 [NOIP2005 普及组\] 采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1048))

###### 思路

​	我们首先来分析一下题目的意思，师傅让你去一个山洞探险，山洞里面的药草每一株有他自己的价值，并且每踩一株需要一段时间，山洞里面所有药草都只有一种，要求我们输出在给定时间内可以取到的药草的最大价值。

​	好了，题目的重点我们已经提取完毕，思维比较好的同学可能现在就已经看出来了，这不就是刚才买水果的问题吗？不要怀疑自己，这个问题就是01背包问题。

​	我们给没有想明白的同学讲解一下这个思路。我们可以看到药草每个只有一种，并且我们只能选择拔出该药草，或者不拔出该药草，我们的时间还是有界限的。那么我们换一个说法，药草我们看为刚才问题中的水果，时间我们看为刚才问题中水果的价值，时间界限我们看为背包容量。我们很自然的将该问题改变为了01背包问题。

###### 代码实现

~~~~c++
struct yaocao {
    int val;//价值
    int w;//重量
}o[Nn];
int dp[Nn];
int v;//时间容量
int n; //药草种类
int main() {
    cin >> v >> n;
    for (int i = 1; i <= n; i++) {
        cin >> o[i].w >> o[i].val;
    }
    for (int i = 1; i <= n; i++) { //表示的选择的第几个药草
        for (int j = v; j >= o[i].w; j--) {  //表示时间
            dp[j] = max(dp[j], dp[j - o[i].w] + o[i].val);
        }
    }
    cout << dp[v];
    return 0;
}
~~~~

#### 完全背包问题

​	我们在上文已经讲述过01背包问题，01背包问题的特点是物品有限，背包容量有限。接下来我们要背包问题的另一种，完全背包问题。

​	首先我们先介绍一下完全背包问题是什么，完全背包问题指的是背包容量依然有限但是物品的数量变成无限个。每个物品都有无数件，只要空间足够多，一种物品可以拿满。

​	由于水果的例子大家已经懂了，所以在此直接引入题目。

##### [P1616 疯狂的采药 - 洛谷](https://www.luogu.com.cn/problem/P1616)

###### 思路

​	让我们先提取一下题目中的重要信息。依旧是去采草药，但是与上一道题不同的是，这道题目中，草药的采摘次数变成了无限次。可见，本题从01背包问题转变成了我们现在所要讲述的完全背包问题。

​	我们首先来确定一下本题中可能出现的状态，根据想要求出的最优解，必然是在我们在取出不同的药草之后总结出的，根据背包的大小，我们所能取出不同种类的数目将会变得很多，我们这时候就应该采用动态规划的思想。

​	每一株草药均可以取无限次，那么我们可以将我们的背包剩余容量作为一个轴，在剩余容量为j的时候，我们判断此时是否应该拿一株该草药，如果现在拿草药比我们之前所保存的值要大的话，就刷新当前容量的最优解，该操作的顺序应该是从背包恰好能装下一株该草药开始，然后向后逐步添加，这样才能保证不同容量下，都能存取该种草药最多次，以保证答案的正确性。重复以上操作，根据局部最优解逐步推断出全局最优解。

​	动态回归方程如下：
$$
dp[j]=max(dp[j],dp[j-v[i]]+w[i])
$$

###### 代码实现

~~~~c++
ll dp[NN];
int main() {
    ll n, m;
    cin >> n >> m;  //n为背包容量   m为药草数目
    for (int i = 1; i <= m; i++) {    //该层循环用于读入当前草药的数据
        ll a, b;
        cin >> a >> b;  //a为草药每株采取所需时间 b为该药草的单价
        for (int j = a; j <= n; j++) {  //从小到大推背包容量
            dp[j] = max(dp[j], dp[j - a] + b);  //动态回归方程
        }
    }
    cout << dp[n];
    return 0;
}
~~~~

#### 多重背包问题

​	多重背包问题是结合了上面两背包特点的复合问题。

​	多重背包问题中，背包的容量有限，有n种物品，每种物品有它对应的价值val，每种物品每件占一定的体积。要求我们如何将这些物品装入背包中，使物品体积总和不超过背包容量且总价值最大。

​	我们可以观察到每种物品的数量是有限个的，聪明的同学应该可以想到，我们可以将该问题转化为01背包问题。将每种物品的拆成一个一个单个物品。

​	按照该思路让我们写一份代码。

##### [U280382 多重背包问题]([U280382 多重背包问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/U280382))

###### 思路

​	代码思路如上所示。

###### 代码实现

~~~c++
ll v[N],w[N];
ll dp[N];
ll n,m;
ll cnt=1;
ll a,b,c;
int main()
{
    cin>>n>>m;
    for(ll i=1;i<=n;i++)
    {
        cin>>a>>b>>c;
        for(ll j=1;j<=c;j++)
        {
            v[cnt]=a;
            w[cnt]=b;
            cnt++;
        }
    }
    for(ll i=1;i<=cnt;i++)
    {
        for(ll j=m;j>=v[i];j--)
        {
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
        }
    }
    cout<<dp[m];
    return 0;
}
~~~

## 子序列与子串的区别

​	在介绍下列问题之前，首先要向大家普及一个基础知识。

​	子串：按原顺序依次出现，禁止跳过某元素

​	子序列：在保持元素前后关系的前提下，可以跳过某些元素的序列

​	举个例子：1 2 3 4 5 6 7 8 9

​	它的子序列有：1 3 4 5 ，2 4 5 8...

​	它的子串有：1 2，2 3，3 4 5，6 7 8 9.....

## LIS问题

​	最长上升子序列问题。

​	让我们来介绍一下什么是LIS问题：给你一个无序的数字序列，让你寻找到在这个数列中，长度最长的上升子序列。

​	举个例子：1 3 2 2 4 5 6 7 4 9

​	它的最长不降子序列为：1 3 4 5 6 7 9

​	严格来说最长不降子序列也属于LIS问题。

#### 状态方程设计

​	在数列中，对于每个数据，它所对应的对于它之前的所有数据，它必然存在一个固定的最长子序列，则证明从一到该点的长度唯一。所以在我们设计状态回归方程的时候，dp中i表示以i结尾的数据的最长单调子序列的长度。

​	那么我们的状态dp中存储的就是以Ai为结尾的LIS长度。

​	然后我们来确定状态的初态，第一个值的LIS长度必然为1所以我们初始化dp1为1。

​	可得出状态回归方程
$$
dp[i]=max(dp[i],dp[j]+1)
$$


​	该问题的时间复杂度为：O(N^2)

#### [P1020 [NOIP1999 普及组] 导弹拦截]([P1020 [NOIP1999 普及组\] 导弹拦截 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1020))

###### 思路讲解

​	首先我们解读一下题意，题目中给出一种导弹拦截系统，该系统的拦截规则为，在拦截每个导弹的时候拦截该个导弹一定要比前一个导弹高度低。由于只有这一种规则，不一定一个拦截装置就可以拦截所有的导弹。题目中有两个问题，问题一：让我们求出该系统可以最多拦截多少导弹，问题二：如果我们要拦截所有导弹最少要配备多少导弹拦截系统。

​	对于问题一，我们会有疑问，题目中很明显要求我们的是求出最长下降子序列啊，跟我们所研究的LIS问题完全相。那么，我们可以将题目中所给的序列反着看，问题就变成了找最长上升子序列。

​	或者，我们可以修改dp中的判断，让我们求出的就是最长下降子序列的个数。

​	对于问题二，要求我们求出最少需要多少组该装置才能拦截所有的导弹。我们可以想到，所有的导弹均是由前一个系统来拦截的，每拦截一个导弹，该系统所能拦截的最大高度下降，所以我们统计问题二的答案的时候，我们求出给定的数字序列中，最长上升子序列即可。

###### 代码实现

~~~c++
int dp[Nn];
int a[Nn];
int n = 0;
int ans = 0;
int main() {
    fastread();
    while (cin >> a[++n]);
    for (int i = 1; i <= n-1; i++) {  //求最长不升子序列
        dp[i] = 1;
        for (int j = 1; j < i; j++) {
            if (a[j] >= a[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        ans = max(ans, dp[i]);
    }
    cout << ans<<"\n";
    ans = 0;
    for (int i = 1; i <= n - 1; i++) {  //求最长不升子序列
        dp[i] = 1;
        for (int j = 1; j < i; j++) {
            if (a[j] < a[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        ans = max(ans, dp[i]);
    }
    cout << ans;
    return 0;
}
~~~



## LIS问题优化

​	新建一个low数组，low[i]表示长度为i的LIS结尾元素的最小值。对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。因此，我们只需要维护low数组，对于每一个a[i]，如果a[i] > low[当前最长的LIS长度]，就把a[i]接到当前最长的LIS后面，即low[++当前最长的LIS长度]=a[i]。

​	对于每一个a[i]，如果a[i]能接到LIS后面，就接上去；否则，就用a[i]取更新low数组。具体方法是，在low数组中找到第一个大于等于a[i]的元素low[j]，用a[i]去更新low[j]。如果从头到尾扫一遍low数组的话，时间复杂度仍是O(n^2)。我们注意到low数组内部一定是单调不降的，所有我们可以二分low数组，找出第一个大于等于a[i]的元素。二分一次low数组的时间复杂度的O(logn)，所以总的时间复杂度是O(nlogn)。

#### [P1020 [NOIP1999 普及组] 导弹拦截]([P1020 [NOIP1999 普及组\] 导弹拦截 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1020))

#### 思路

​	同上文。

#### 代码实现

~~~c++
int low[Nn];
int a[Nn];
int low2[Nn];
int main() {
    fastread();
    int n = 0;
    while (cin >> a[++n]);
    memset(low, MAXN, sizeof(low));
    memset(low2, MAXN, sizeof(low2));
    low[1] = a[1];
    low2[1] = a[1];
    int ans = 1;
    int ans2 = 1;
    n--;
    for (int i = 2; i <= n; i++) { 
        if (a[i] <= low[ans]) {//求最长不增子序列
            low[++ans] = a[i];
        }
        else {
            low[upper_bound(low + 1, low + 1 + ans, a[i], greater<int>()) - low] = a[i];
        }
        if (a[i] > low2[ans2]) {//求最长上升子序列
            low2[++ans2] = a[i];
        }
        else {
            low2[lower_bound(low2 + 1, low2 + 1 + ans2, a[i]) - low2] = a[i];
        }
    }
    cout << ans << "\n" << ans2;
    return 0;
}
~~~



## LCS问题

​	最长公共子序列问题。

​	LCS问题的描述为：给定两个整数序列a和b，找它们所有的公共子序列中最长的序列，输出其长度。

#### 状态方程设计

​	在我们解决LIS问题的时候，是对于单个序列的研究，但LCS问题的结果同时受到两个序列的影响，所以状态需要用2维表示。

​	那我们就可以以dpij表示a中从1到i，b中从1到j范围内最长的公共子序列长度，那么考虑对于状态dpij可以由那些转台转移来，我们可以做出以下分析。

​	若ai=bj那么ai,bj同时属于公共子序列，dpij就应该是由dp i-1 j-1转移过来的，并且转移的时候长度+1。若ai!=bj那么ai与bj不能同属于公共子序列，此基础上细分出：ai不属于公共子序列：dpij由dpi-1 j转移过来。bj不属于公共子序列：dpij由dpi j-1转移而来，dpij = dpi j-1。ai和bj都不属于公共子序列，该种决策可以舍去，dpi j的更新均是由dp i-1 j-1转移过来的，其一定大于dpi-1 j-1。

​	根据以上分析我们可以得出状态转移方程：
$$
dp[i][j]=max(max(dp[i-1][j],dp[i][j]),dp[i-1][j-1]+(a[i-1]==b[j-1]))
$$

#### [P1439 【模板】最长公共子序列]([P1439 【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1439))

##### 思路

​	与上文所描述相同。

##### 代码实现

~~~c++
int dp[nN][nN];
int a[nN], b[nN];
int main() {
    fastread();
    int n;
    cin>>n;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<n;i++)cin>>b[i];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n+1; j++) {
            dp[i][j] = max(max(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + (a[i - 1] != b[j - 1]));
        }
    }
    cout << dp[n][n];
    return 0;
}
~~~

## LCS问题优化

​	在讲述LCS问题中，我们可以发现，LCS问题的时间复杂度是O(n^2)，在绝大部分问题中，这个时间复杂度是不能被容忍的，那么我们是否可以考虑一中方式，来讲LCS问题优化掉。

​	我们考虑一下，如何将LCS问题转化为LIS问题进行处理。

​	我们想到如下优化方式：将B序列的数字编号，对应到A数组中，在A数组中寻找最长上升子序列，该最长子序列就为两序列的最长公共子序列，如此LCS问题转化为LIS问题。

#### [P1439 【模板】最长公共子序列]([P1439 【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1439))

##### 思路

​	与上文所描述相同。

##### 代码实现

~~~c++
int o[Nn];
int n;
map<int, int>p;
int low[Nn];
int main() {
    fastread();
    cin >> n;
    for (int i = 1; i <= n; i++)cin >> o[i];
    for (int i = 1; i <= n; i++) {  //离散化
        int k; cin >> k; p[k] = i;
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (p[o[i]] > low[ans]) {  //LIS求最长不降子序列
            low[++ans] = p[o[i]];
        }
        else {
            low[lower_bound(low + 1, low + 1 + ans, p[o[i]]) - low] = p[o[i]];
        }
    }
    cout << ans;
    return 0;
}
~~~

## 区间动态规划

​	区间dp是一种dp的应用，用于解决涉及区间的问题。

​	如果一个问题最终被分解成为两个连续的部分（一个序列被分割为两个子段），然后再合并，那么几乎可以确定是区间规划问题。区间动态规划用于求区间上的最优值，对于整个区间的最优值来说，通过枚举区间左右两部分的分割点（合并点），将问题分解成为左右两部分的子问题，最后将左右两个子问题的最优值进行合并计算得到原问题的最优值。

​	让我们用一道例题来引入该问题

#### [P1775 石子合并(弱化版)](https://www.luogu.com.cn/problem/P1775)

​	让我们首先来分析一下题意。题目中给出具有顺序的一个石子序列，每个数据对应着石子的质量，题目要求我们将石子合并为一堆，每次只能合并相邻的两堆石子，问我们应该如何操作才能使合并的总代价最小。

​	我们看到这个题可能首先会想到贪心的解法，就是将每次都将较小的两堆合在一起，最后会得出一个在贪心理论下的最小代价。但是，在这个题目中，这种想法是不成立的。为什么呢？是因为这道题中我们可以合并的石子每次必须是相邻的两堆，而相邻的两堆合在一起并不一定会让最后的代价最小。

​	这时我们应该想到动态规划的解法，我们就要用到我们所要讲述到的区间动态规划了。

###### 状态方程设计

​	对于动态规划问题，状态转移方程设计是问题的关键。对于本问题中，不同的两个相邻区间的代价值，就是本问题的状态。这是因为我们在合并的过程中，每次只关注于每个子区间内的代价为多少。n个石子合并的代价如果我们设置为DP(1,n)，那么在最后一次合并前，一定已经合并成了两堆了，这两堆的分割方法方法有很多的可能性。比如左边的一个石子单独合并为一堆，右边(n-1)个石子合并为一堆。那么我们的问题就转变为了DP(1,1)+DP(1,n)。当然，分割的方式有很多种。

​	由上述所示，我们可以推到出动态规划状态转移方程：
$$
dp[i][k] = min(dp[i][k], dp[i][j] + dp[j + 1][k] + sum[k] - sum[i - 1]);
$$

###### 核心代码实现

~~~c++
for (int l = 2; l <= n; l++) {  //枚举区间长度
	for (int i = 1; i <= n - l + 1; i++) {
		int k = i + l - 1;
		dp[i][k] = MAXN;
		for (int j = i; j < k; j++) {
			dp[i][k] = min(dp[i][k], dp[i][j] + dp[j + 1][k] + sum[k] - sum[i - 1]);
		}
	}
}
~~~

#### [Zuma](https://www.luogu.com.cn/problem/CF607B)

###### 思路

​	题意中给出一串宝石序列，我们可以由题目得出当我们每次都可以挑选一个回文的连续子串进行消除，删除后，剩余的串将连接在一起，形成一个新的串，求把串全部删除完需要的最小次数。

​	因为我们需要处理这组序列中的连续回文子串，我们可以看出每个区间的求解都可以分解为更小的两个区间的求解，自然而然的想到用区间DP来求解。

​	设DP(i,j)为左端点为i右端点为j的最优解，不难推导出动态回归方程:
$$
dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j]);
$$

###### 代码实现

~~~c++
ll dp[550][550];
ll n;
ll o[550];
int main() {
	fastread();
	cin >> n;
	for (int i = 1; i <= n; i++)cin >> o[i];
	for (int i = 1; i <= n; i++)dp[i][i] = 1;
	for (int l = 1; l < n; l++) {
		for (int i = 1; i <= n && i + l <= n; i++) {
			int j = l + i;
			dp[i][j] = MAXN;
			if (o[i] == o[j]) {
				if (j == i + 1)  dp[i][j] = dp[i + 1][j - 1] = 1;
				else dp[i][j] = dp[i + 1][j - 1];
			}
			for (int mid = i; mid < j; mid++) {
				dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j]);
			}
		}
	}
	cout << dp[1][n];
	return 0;
}
~~~

## 环形动态规划

​	环形动态规划指的是，题目中给定的一串序列具有环形特点的一种特殊的区间动态规划题目。

​	我们在上文已经讲过了区间动态规划该怎么进行求解，再加上环形这一特殊条件后，其实对于每个区间来说本质并没有发生太大的改变。那么我们如何处理环形问题呢？我们可以将环形破链，然后复制一份相同的加在该链后面，这样在环形中所能取到的所有区间便在这一整个链中都能取到了。

#### [石子合并](https://www.luogu.com.cn/problem/P1880)

​	本题目在弱化版的基础上，给定的石子序列变成了环形，我们在将环形破坏成链然后再进行一次复制就变成了基本的区间动态规划问题。

###### 状态方程推导	

​	该问题推导过程与区间动态规划一致，此处就不进行重复讲述。
$$
dp[i][k] = min(dp[i][k], dp[i][j] + dp[j + 1][k] + sum[k] - sum[i - 1]);
$$

#### 代码实现

~~~c++
ll dp1[550][550];
ll dp2[550][550];
ll n;
ll o[550];
ll sum[550];
int main() {
	fastread();
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> o[i];
		o[i + n] = o[i];
	}
	for (int i = 1; i <= 2 * n; i++) {
		sum[i] = sum[i - 1] + o[i];
	}
	for (int len = 1; len < n; len++) {
		for (int i = 1; i <= n * 2&&i+len<=n*2; i++) {
			int j = len + i;
			dp1[i][j] = MAXN;
			for (int k = i; k < j; k++) {
				dp1[i][j] = min(dp1[i][j], dp1[i][k] + dp1[k + 1][j] + sum[j] - sum[i - 1]);
				dp2[i][j] = max(dp2[i][j], dp2[i][k] + dp2[k + 1][j] + sum[j] - sum[i - 1]);
			}
		}
	}
	ll ans1 = MAXN;
	ll ans2 = -MAXN;
	for (int i = 1; i < n; i++) {
		ans1 = min(ans1, dp1[i][i + n - 1]);
		ans2 = max(ans2, dp2[i][i + n - 1]);
	}
	cout << ans1 << "\n" << ans2;
	return 0;
}
~~~



